{
  "name": "toposort",
  "version": "0.2.10",
  "description": "Topological sort of directed ascyclic graphs (like dependecy lists)",
  "main": "index.js",
  "scripts": {
    "test": "node test.js"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/marcelklehr/toposort.git"
  },
  "devDependencies": {
    "vows": "*"
  },
  "keywords": [
    "topological",
    "sort",
    "sorting",
    "graphs",
    "graph",
    "dependency",
    "list",
    "dependencies",
    "acyclic"
  ],
  "author": {
    "name": "Marcel Klehr",
    "email": "mklehr@gmx.net"
  },
  "license": "MIT",
  "readmeFilename": "README.md",
  "readme": "# Toposort\r\n\r\nSort directed acyclic graphs\r\n\r\n[![Build Status](https://travis-ci.org/marcelklehr/toposort.png)](https://travis-ci.org/marcelklehr/toposort)\r\n\r\n## Installation\r\n\r\n`npm install toposort` or `component install marcelklehr/toposort`  \r\n\r\nthen in your code:\r\n\r\n```js\r\ntoposort = require('toposort')\r\n```\r\n\r\n## Example\r\n\r\nLet's say you are compiling a project consisting of 5 modules. You know there are some dependencies between them so you want to figure a safe execution order to run them in. Lets assume we have tool which spits out dependency data for us:\r\n\r\n```\r\nvar project = [\r\n  {name: \"foo\", depends: ['bar']},\r\n  {name: \"bar\", depends: [\"ron\"]},\r\n  {name: \"john\", depends: [\"bar\"]},\r\n  {name: \"tom\", depends: [\"john\"]},\r\n  {name: \"ron\", depends: []}\r\n]\r\n```\r\n\r\nWhich if visualized in a graph:\r\n\r\n![graph](out.png)\r\n\r\nreveals two safe execution orders:\r\n\r\n+ `ron -> bar -> foo -> john -> tom`\r\n+ `ron -> bar -> john -> tom -> foo`\r\n\r\nLet's see if we can get `toposort` to figure that out for us. First though we need to translate the dependency information into something it can understand. The way `toposort` understands relationships is with edges. An \"edge\" is a 2 item `Array` where the first item is the subject and the 2nd item is the target.  \r\n\r\nWith edges our data looks like this: \r\n\r\n```js\r\nvar modules = [\r\n  [\"foo\", \"bar\"],\r\n  [\"bar\", \"ron\"],\r\n  [\"john\", \"bar\"],\r\n  [\"tom\", \"john\"]\r\n]\r\n```\r\n\r\nRunning it through `toposort` we get:\r\n\r\n```js\r\nvar results = toposort(modules)\r\n\r\nconsole.dir(results)\r\n// => [ 'tom', 'john', 'foo', 'bar', 'ron' ]\r\n```\r\nSo `toposort` prefered the first path through the graph. Since it was the first it encountered.\r\n\r\nNow, we to get the best execution order, we can just reverse the returned array:\r\n\r\n```js\r\nconsole.dir(results.reverse())\r\n// => [ 'ron', 'bar', 'foo', 'john', 'tom' ]\r\n```\r\n\r\n## API\r\n\r\n### toposort(edges)\r\n\r\n+ edges {Array} An array of directed vertices like `[node1, node2]` (where `node1` depends on `node2`) -- these needn't be strings but can be of any type\r\n\r\nReturns: {Array} a list of nodes, sorted from least dependencies to most\r\n\r\n### toposort.array(nodes, edges)\r\n\r\n+ nodes {Array} An array of nodes\r\n+ edges {Array} As with `toposort`. Edges doesn't necessarily need to contain all the items in `nodes`. However, the ordering of the items you don't mention will be undefined.\r\n\r\nReturns: {Array} as per `toposort`\r\n\r\n## Tests\r\n\r\nRun the tests with `node test.js`.\r\n\r\n## Legal\r\n\r\nMIT License",
  "bugs": {
    "url": "https://github.com/marcelklehr/toposort/issues"
  },
  "_id": "toposort@0.2.10",
  "dist": {
    "shasum": "bd86f4bb2408307d1912ba6aacbd01790a64fd2c",
    "tarball": "http://registry.npmjs.org/toposort/-/toposort-0.2.10.tgz"
  },
  "_from": "toposort@^0.2.10",
  "_npmVersion": "1.3.7",
  "_npmUser": {
    "name": "marcelklehr",
    "email": "mklehr@gmx.net"
  },
  "maintainers": [
    {
      "name": "marcelklehr",
      "email": "mklehr@gmx.net"
    }
  ],
  "directories": {},
  "_shasum": "bd86f4bb2408307d1912ba6aacbd01790a64fd2c",
  "_resolved": "https://registry.npmjs.org/toposort/-/toposort-0.2.10.tgz",
  "homepage": "https://github.com/marcelklehr/toposort"
}
